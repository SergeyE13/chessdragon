<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–®–∞—Ö–º–∞—Ç–Ω—ã–π –î—Ä–∞–∫–æ–Ω</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 5px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: start;
        }

        .game-board {
            background: white;
            border-radius: 15px;
            padding: 35px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board-container {
            position: relative;
            margin: 10px 0;
        }

        .coordinates {
            position: absolute;
            color: #333;
            font-size: 14px;
            font-weight: 800;
        }

        .file-labels {
            bottom: -20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 15px;
        }

        .rank-labels {
            top: 0;
            bottom: 0;
            left: -30px;
			width: 25px;			
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 2px solid #2c3e50;
            border-radius: 8px;
            overflow: hidden;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .square.light {
            background-color: #b58863;
        }

        .square.dark {
            background-color: #f0d9b5;
        }

        .square.selected {
            background-color: #f7dc6f !important;
        }

        .square.last-move {
            box-shadow: inset 0 0 0 3px rgba(255, 193, 7, 0.8);
        }

        .square.legal-move::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid rgba(52, 152, 219, 0.9);
            box-sizing: border-box;
            pointer-events: none;
        }

        .square.legal-move.has-piece::after {
            border: 3px solid rgba(231, 76, 60, 0.9);
        }

        .square.dragon-drop::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid rgba(155, 89, 182, 0.9);
            box-sizing: border-box;
            pointer-events: none;
            background: rgba(155, 89, 182, 0.2);
        }

        .piece {
            font-size: 50px;
            line-height: 1;
            text-shadow: 0 0 2px rgba(0,0,0,0.3);
            z-index: 1;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 280px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 16px;
        }
		
		/* –°—Ä—É–±–ª–µ–Ω–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã */
		.captured-pieces-container {
			display: flex;
			justify-content: space-between;
			margin: 5px 0;
			margin-top: 30px;
			gap: 10px;
		}

		.captured-section {
			flex: 1;
			background: #f8f9fa;
			border-radius: 8px;
			padding: 8px;
			min-height: 50px;
		}

		.captured-label {
			font-size: 11px;
			color: #666;
			font-weight: 600;
			margin-bottom: 5px;
			text-align: center;
		}

		.captured-list {
			display: flex;
			flex-wrap: wrap;
			gap: 3px;
			justify-content: center;
			min-height: 30px;
		}

		.captured-piece {
			font-size: 32px;
			line-height: 1;
			opacity: 0.7;
			transition: opacity 0.2s;
		}

		.captured-piece:hover {
			opacity: 1;
		}		

        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: #3498db;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 8px;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .status-display {
            text-align: center;
            margin: 0;
            flex: 1;
        }

        #status {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            padding: 10px;
            border-radius: 8px;
            background: #ecf0f1;
            margin-bottom: 10px;
        }

        .pockets {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            padding: 2px;
            background: #f8f9fa;
            border-radius: 8px;
            gap: 30px;
        }

        .pocket {
            text-align: center;
            flex: 1;
        }

        .pocket-label {
            display: none;
        }

        .pocket-pieces {
            font-size: 36px;
            min-height: 45px;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .pocket-pieces:hover {
            background-color: #e9ecef;
        }

        .pocket-pieces.selected {
            background-color: #9b59b6;
            color: white;
        }

        .evaluation {
            margin: 8px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .evaluation h3 {
            color: #2c3e50;
            margin-bottom: 12px;
            font-size: 14px;
            text-align: center;
        }

        .evaluation-bar-container {
            position: relative;
            width: 100%;
            height: 30px;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #7f8c8d;
        }

        /* –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 2: –î–≤–µ —Å–µ–∫—Ü–∏–∏ –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π —Å–º–µ–Ω—ã —Ü–≤–µ—Ç–æ–≤ */
        .evaluation-player-section {
            position: absolute;
            top: 0;
            height: 100%;
            transition: all 0.3s ease;
        }

        .evaluation-computer-section {
            position: absolute;
            top: 0;
            height: 100%;
            transition: all 0.3s ease;
        }

        .evaluation-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 11px;
            color: #7f8c8d;
        }

        .evaluation-text {
            text-align: center;
            font-weight: 700;
            margin-top: 8px;
            font-size: 18px;
        }

        .evaluation-text.positive {
            color: #27ae60;
        }

        .evaluation-text.negative {
            color: #e74c3c;
        }

        .evaluation-text.neutral {
            color: #7f8c8d;
        }

        .engine-thinking {
            opacity: 0;
			visibility: hidden;      /* ‚Üê –î–û–ë–ê–í–ò–¢–¨ */
            transition: opacity 0.3s ease;
            text-align: center;
            padding: 10px;
            background: #fff3cd;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .engine-thinking.active {
            opacity: 1;
			visibility: visible;     /* ‚Üê –î–û–ë–ê–í–ò–¢–¨ */			
        }
		
		/* ‚úÖ –î–û–ë–ê–í–ò–¢–¨ –Ω–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –ø–æ–∫–∞–∑–∞ –±–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏ */
		.engine-thinking.show-now {
			opacity: 1;
			visibility: visible;
			transition: none;
		}		

        .move-history {
            background: white;
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 280px;
            max-height: 400px;
            overflow-y: auto;
        }

        .move-history h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .move-list {
            font-family: monospace;
            font-size: 14px;
            line-height: 1.8;
        }

        .move-pair {
            display: flex;
            margin-bottom: 5px;
        }

        .move-number {
            width: 30px;
            color: #666;
            font-weight: bold;
        }

        .move {
            flex: 1;
            margin-right: 10px;
        }
		
		// ===== CSS: —Å—Ç–∏–ª–∏ –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ =====
		.promotion-modal {
			display: none;
			position: fixed;      /* ‚Üê –ì–õ–ê–í–ù–û–ï: fixed, –Ω–µ absolute */
			z-index: 10000;       /* ‚Üê –ì–õ–ê–í–ù–û–ï: –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π */
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.6);
			align-items: center;
			justify-content: center;
		}

		.promotion-modal.active {
			display: flex !important;  /* ‚Üê –î–æ–±–∞–≤—å—Ç–µ !important */
		}

		.promotion-content {
			background: white;
			border-radius: 15px;
			padding: 25px;
			box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4);
			text-align: center;
			animation: modalFadeIn 0.3s ease;
			
			position: relative;
			top: auto;
			left: auto;
			margin: auto;           /* ‚Üê –ì–õ–ê–í–ù–û–ï: —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ */
			width: auto;
			max-width: 95vw;
			max-height: 95vh;
		}


		@keyframes modalFadeIn {
			from {
				opacity: 0;
				transform: scale(0.9);
			}
			to {
				opacity: 1;
				transform: scale(1);
			}
		}
		
		.promotion-content h3 {
			margin-bottom: 15px;  /* –ë—ã–ª–æ 20px */
			font-size: 18px;       /* –ë—ã–ª–æ 20px */
		}		

		.promotion-pieces {
			display: flex;
			gap: 10px;             /* –ë—ã–ª–æ 15px */
			justify-content: center;
			flex-wrap: wrap;       /* –î–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–µ–Ω–æ—Å */
		}

		.promotion-piece-btn {
			width: 70px;
			height: 70px;
			border: 3px solid #3498db;
			border-radius: 12px;
			background: white;
			font-size: 55px;           /* ‚Üê –ì–õ–ê–í–ù–û–ï: –±–æ–ª—å—à–æ–π —Ä–∞–∑–º–µ—Ä */
			line-height: 1;            /* ‚Üê –î–û–ë–ê–í–ò–¢–¨ */
			cursor: pointer;
			transition: all 0.2s ease;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 0;
			font-weight: bold;         /* ‚Üê –î–û–ë–ê–í–ò–¢–¨ */
			color: black;              /* ‚Üê –î–û–ë–ê–í–ò–¢–¨ */
		}

		.promotion-piece-btn:hover {
			border-color: #2980b9;
			background: #ecf0f1;
			transform: scale(1.15);
			box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
		}


		.promotion-piece-btn:active {
			transform: scale(0.95);
		}
		
		/* –∫–Ω–æ–ø–∫–∞ –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ–∑–∏—Ü–∏—é */
		.position-display {
			margin-top: 10px;
			padding: 10px;
			background: #f8f9fa;
			border-radius: 8px;
			display: none;
		}

		.position-display.active {
			display: block !important;  /* –î–æ–±–∞–≤–∏–ª–∏ !important */
		}		

		.position-textarea {
			width: 100%;
			min-height: 70px;
			padding: 10px;
			border: 2px solid #3498db;
			border-radius: 6px;
			font-family: 'Courier New', monospace;
			font-size: 12px;
			resize: vertical;
			box-sizing: border-box;
			color: #333;
			background: white;
		}		

		.position-textarea:focus {
			outline: none;
			border-color: #2980b9;
			box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
		}
		
		/*--–±–ª–æ–∫ –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞--*/
		@media (max-width: 480px) {
			.captured-pieces-container {
				margin: 3px 0;
			}
			
			.captured-section {
				padding: 5px;
			}
			
			.captured-piece {
				margin-top: 6px;			
				font-size: 24px;
				display: inline-block;						
				flex-wrap: wrap;  /* ‚úÖ –ü–µ—Ä–µ–Ω–æ—Å –Ω–∞ 2 —Å—Ç—Ä–æ–∫–∏ */
				gap: 4px;
				max-width: 180px;  /* ‚úÖ –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —à–∏—Ä–∏–Ω—É */				
			}
			
			.promotion-content {
				padding: 12px;
				/* margin: 10px; */
			}
			
			.promotion-piece-btn {
				width: 45px;
				height: 45px;
				font-size: 32px;
			}			
		}			

        @media (max-width: 768px) {
			.container {
                grid-template-columns: 1fr;
				gap: 5px;
			}
            
            .controls, .move-history {
                width: 100%;
				padding: 8px;
                max-width: 480px;
                margin: 0 auto;
            }

			.game-board {
            background: white;
            border-radius: 15px;
            padding: 35px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
            
            #board {
                grid-template-columns: repeat(8, 45px);
                grid-template-rows: repeat(8, 45px);
            }
            
            .piece {
                font-size: 38px;
            }

			.pockets {
				margin: 1px;
				padding: 2px;
			}

            .pocket-pieces {
                font-size: 28px;
            }

			.evaluation {
				margin: 5px 0;
				padding: 8px;
			}

		   .captured-pieces-container {
				margin: 20px 0 5px ;
			}
			
			.captured-section {
				padding: 5px;
				min-height: 40px;
			}
			
			.captured-label {
				font-size: 10px;
				margin-bottom: 3px;
			}
			
			.captured-piece {
				display: flex;
				flex-wrap: wrap;  /* ‚úÖ –ü–µ—Ä–µ–Ω–æ—Å –Ω–∞ 2 —Å—Ç—Ä–æ–∫–∏ */
				gap: 6px;
				max-width: 220px;  /* ‚úÖ –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —à–∏—Ä–∏–Ω—É */			
				font-size: 22px;
				margin: 3px;
				display: inline-block;				
			}
			
			.promotion-content {
				padding: 15px;
				margin: 20px;
			}			
			
			.promotion-piece-btn {
				width: 50px;
				height: 50px;
				font-size: 35px;
			}			
			
			.position-textarea {
				font-size: 14px;
				min-height: 40px;
			}			
			
			body {
				padding: 3px;
			}
			
			button {
				padding: 10px;
				margin-bottom: 6px;
			}			
        }
			
    
        /* ‚úÖ –ù–∞ –æ–¥–Ω–æ–π –ª–∏–Ω–∏–∏: –†–µ–∑–µ—Ä–≤ –±–µ–ª—ã—Ö | –°—Ç–∞—Ç—É—Å | –†–µ–∑–µ—Ä–≤ —á—ë—Ä–Ω—ã—Ö */
        .header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 30px;
            width: 100%;
            margin-bottom: 15px;
        }
        </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <div class="control-group">
                <button onclick="newGame()">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                <button onclick="flipBoard()">–°–º–µ–Ω–∏—Ç—å —Ü–≤–µ—Ç</button>
                <button onclick="undoMove()">–û—Ç–º–µ–Ω–∏—Ç—å —Ö–æ–¥</button>
                <button id="autobtn" onclick="toggleAutoPlay()" style="margin-left:5px;background:#4CAF50;color:white;padding:8px 12px;border:none;border-radius:4px;cursor:pointer;font-weight:bold;">üêâ –ê–≤—Ç–æ–∏–≥—Ä–∞</button>
				<button onclick="togglePositionDisplay()" id="position-toggle-btn" class="control-btn">
					–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–∑–∏—Ü–∏—é
				</button>

				<div id="position-display" class="position-display">
					<textarea 
						id="position-input" 
						class="position-textarea" 
						placeholder="–í–≤–µ–¥–∏—Ç–µ FEN –ø–æ–∑–∏—Ü–∏—é..."
						onchange="onPositionChanged()"
						oninput="onPositionChanged()"
					></textarea>
				</div>
				
            </div>
            
            <div class="control-group">
                <h3>–£—Ä–æ–≤–µ–Ω—å</h3>
				<select id="difficulty" onchange="setDifficulty(this.value)">
					<option value="0">–£—Ä–æ–≤–µ–Ω—å 0 (500)</option>
					<option value="1">–£—Ä–æ–≤–µ–Ω—å 1 (800)</option>
					<option value="2">–£—Ä–æ–≤–µ–Ω—å 2 (1000)</option>
					<option value="3">–£—Ä–æ–≤–µ–Ω—å 3 (1200)</option>
					<option value="4" selected>–£—Ä–æ–≤–µ–Ω—å 4 (1400)</option>
					<option value="5">–£—Ä–æ–≤–µ–Ω—å 5 (1600)</option>
					<option value="6">–£—Ä–æ–≤–µ–Ω—å 6 (1800)</option>
					<option value="7">–£—Ä–æ–≤–µ–Ω—å 7 (2000)</option>
				</select>			
            </div>
			

            <div class="evaluation">
                <h3>–û—Ü–µ–Ω–∫–∞ –ø–æ–∑–∏—Ü–∏–∏</h3>
                <div class="evaluation-bar-container">
                    <div class="evaluation-player-section" id="evaluation-player"></div>
                    <div class="evaluation-computer-section" id="evaluation-computer"></div>
                </div>
                <div class="evaluation-labels">
                    <span id="player-label">–í—ã</span>
                    <span id="computer-label">–ö–æ–º–ø—å—é—Ç–µ—Ä</span>
                </div>
                <div class="evaluation-text neutral" id="evaluation-text">0.0</div>
            </div>

            <div id="engine-thinking" class="engine-thinking">
                <div style="font-weight: bold; margin-bottom: 5px;">ü§î –ö–æ–º–ø—å—é—Ç–µ—Ä –¥—É–º–∞–µ—Ç...</div>
				<div id="search-info" style="font-size: 12px; color: #666; 
					font-family: monospace;
					padding: 5px;
					border-radius: 4px;
					min-height: 20px;">
				</div>

			</div>
        </div>

        <div class="game-board">
            <div class="header-row">
                <div class="pocket">
                    <div class="pocket-label">–†–µ–∑–µ—Ä–≤ –±–µ–ª—ã—Ö</div>
                    <div class="pocket-pieces" id="white-pocket" data-color="white" onclick="selectDragon('white')">‚Äî</div>
                </div>

                <div class="status-display">
                    <div id="status">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                </div>

                <div class="pocket">
                    <div class="pocket-label">–†–µ–∑–µ—Ä–≤ —á—ë—Ä–Ω—ã—Ö</div>
                    <div class="pocket-pieces" id="black-pocket" data-color="black" onclick="selectDragon('black')">‚Äî</div>
                </div>
            </div>
			
			<!-- –ë–ª–æ–∫ –≤—ã–±–æ—Ä–∞ —Ñ–∏–≥—É—Ä—ã -->
			<div id="promotion-modal" class="promotion-modal">
				<div class="promotion-content">
					<h3>–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É</h3>
					<div class="promotion-pieces" id="promotion-pieces"></div>
				</div>
			</div>					

            <div class="board-container">
                <div class="coordinates file-labels" id="file-labels"></div>
                <div class="coordinates rank-labels" id="rank-labels"></div>
                <div id="board"></div>
            </div>	
			
			<!-- –±–ª–æ–∫ —Å—Ä—É–±–ª–µ–Ω–Ω—ã—Ö —Ñ–∏–≥—É—Ä –ø–æ–¥ –¥–æ—Å–∫–æ–π -->
			<div class="captured-pieces-container">
				<div id="white-captured" class="captured-list-inline"></div>
				<div class="captured-divider"></div>
				<div id="black-captured" class="captured-list-inline"></div>
			</div>			
			
        </div>
		
		

        <div class="move-history">
            <h3>–ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤</h3>
            <div class="move-list" id="move-history"></div>
        </div>
    </div>	

    <script type="module">
		//const API_URL = `http://${window.location.hostname}:3000`;
		//const API_URL = `http://gofra.ddns.net:3000`;
		const API_URL = 'http://localhost:3000';
		//const API_URL = 'https://chessdragon.onrender.com';

        let board = null;
        let ffish = null;
        let gameReady = false;
        let playerColor = 'white';
        let boardFlipped = false;
        let lastMoveSquares = { from: null, to: null };
        let selectedSquare = null;
        let selectedDragon = null;
        let currentDifficulty = 4;
        let whiteDragons = 2;
        let blackDragons = 2;
        let moveHistory = [];
		let capturedByWhite = [];
		let capturedByBlack = [];	
		let positionDisplayVisible = false;
		let originalFen = '';  // –î–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
		let pendingPromotionMove = null;
		
		const pieceValues = {
				'P': 100, 'N': 320, 'B': 340, 'R': 500, 'Q': 900, 'K': 20000, 'D': 330,
				'p': -100, 'n': -320, 'b': -340, 'r': -500, 'q': -900, 'k': -20000, 'd': -330
			};
		
		const difficultySettings = {
			0: { depth: 2, name: '–ù–æ–≤–∏—á–æ–∫' },  // –ù–û–í–´–ô —É—Ä–æ–≤–µ–Ω—å —Å –º–∏–Ω–∏–º–∞–∫—Å
			1: { depth: 1, name: '–£—Ä–æ–≤–µ–Ω—å 1 (800)' },
			2: { depth: 2, name: '–£—Ä–æ–≤–µ–Ω—å 2 (1000)' },
			3: { depth: 3, name: '–£—Ä–æ–≤–µ–Ω—å 3 (1200)' },
			4: { depth: 4, name: '–£—Ä–æ–≤–µ–Ω—å 4 (1400)' },
			5: { depth: 5, name: '–£—Ä–æ–≤–µ–Ω—å 5 (1600)' },
			6: { depth: 6, name: '–£—Ä–æ–≤–µ–Ω—å 6 (1800)' },
			7: { depth: 7, name: '–£—Ä–æ–≤–µ–Ω—å 7 (2000)' }
		};		

        function safeBoardCall(callback, defaultValue = null) {
            try {
                if (!board || !gameReady) return defaultValue;
                return callback();
            } catch (error) {
                console.error('Board error:', error);
                if (error.message && error.message.includes('memory access')) {
                    console.warn('Memory error detected, reinitializing...');
                    setTimeout(() => initGame(), 100);
                }
                return defaultValue;
            }
        }

        async function initGame() {
            try {
                gameReady = false;
				capturedByWhite = [];
				capturedByBlack = [];
				updateCapturedPieces();		

				const modal = document.getElementById('promotion-modal');
				if (modal) {
					modal.classList.remove('active');
				}
				pendingPromotionMove = null;		
                
                if (board) {
                    try {
                        board.delete();
                    } catch (e) {
                        console.warn('Could not delete old board:', e);
                    }
                }
                
                if (!ffish) {
                    const Module = await import('https://cdn.jsdelivr.net/npm/ffish-es6@0.7.8/ffish.js');
                    ffish = await Module.default({ 
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/ffish-es6@0.7.8/${file}` 
                    });
                    
                    const variantConfig = `
[ChessDragon:chess]
dragon = d
customPiece1 = d:DA
startFen = rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR[DDdd] w KQkq - 0 1
pieceDrops = true
pieceValueMg = d:900
pieceValueEg = d:800
dropPieceTypes = d
pocketSize = 2
whiteDropRegion = *1, *2
blackDropRegion = *7, *8
promotionPieceTypes = nbrqd
`;
                    ffish.loadVariantConfig(variantConfig);
                }
                
                board = new ffish.Board('ChessDragon');
                whiteDragons = 2;
                blackDragons = 2;
                lastMoveSquares = { from: null, to: null };
                selectedSquare = null;
                selectedDragon = null;
                moveHistory = [];
				positionDisplayVisible = false;
				originalFen = '';
                
                gameReady = true;
                
                updateBoard();
                updatePockets();
                updateEvaluation();
                updateStatus();
                updateCoordinates();

				const display = document.getElementById('position-display');
				if (display) display.classList.remove('active');
				const btn = document.getElementById('position-toggle-btn');
				if (btn) {
					btn.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–∑–∏—Ü–∏—é';
					btn.style.background = '';
				}
				const textarea = document.getElementById('position-input');
				if (textarea) textarea.value = '';
            
                if (playerColor === 'black') {
                    setTimeout(() => makeComputerMove(), 500);
                }
                
            } catch (error) {
                console.error('Init error:', error);
                document.getElementById('status').textContent = '–û—à–∏–±–∫–∞: ' + error.message;
                gameReady = false;
            }
        }


		// ===== –†–µ–∞–ª–∏–∑–∞—Ü–∏—è Minimax –∞–ª–≥–æ—Ä–∏—Ç–º–∞ =====

		// –û—Ü–µ–Ω–∫–∞ –ø–æ–∑–∏—Ü–∏–∏
		function evaluatePosition() {
			const fen = safeBoardCall(() => board.fen());
			if (!fen) return 0;
			
			const boardStr = fen.split(' ')[0].split('[')[0];
			let score = 0;
			
			// –ú–∞—Ç–µ—Ä–∏–∞–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
			for (let char of boardStr) {
				if (pieceValues[char]) {
					score += pieceValues[char];
				}
			}
			
			// –ü–æ–∑–∏—Ü–∏–æ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ (—Ü–µ–Ω—Ç—Ä –¥–æ—Å–∫–∏)
			const centerBonus = 10;
			const centerSquares = ['d4', 'e4', 'd5', 'e5'];
			centerSquares.forEach(sq => {
				const piece = getPieceAtSquare(fen, sq);
				if (piece) {
					if (piece === piece.toUpperCase()) {
						score += centerBonus;
					} else {
						score -= centerBonus;
					}
				}
			});
			
			return score;
		}

		// –°—á–µ—Ç—á–∏–∫ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É–∑–ª–æ–≤ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ Minimax
		let minimaxNodesCount = 0;
		let minimaxUpdateCallback = null;  // –î–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è UI –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏

		// Minimax —Å alpha-beta –æ—Ç—Å–µ—á–µ–Ω–∏–µ–º
		function minimaxFixed(depth, isMaximizing) {
			
			minimaxNodesCount++;  // ‚Üê –î–û–ë–ê–í–ò–¢–¨ –≤ –Ω–∞—á–∞–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏
			// –û–±–Ω–æ–≤–ª—è–µ–º UI –∫–∞–∂–¥—ã–µ 100 —É–∑–ª–æ–≤
			if (minimaxNodesCount % 100 === 0 && minimaxUpdateCallback) {
				minimaxUpdateCallback(minimaxNodesCount);
			}
			
			// –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π: –≥–ª—É–±–∏–Ω–∞ 0
			if (depth === 0) {
				return { score: evaluatePosition(), move: null };
			}
			
			// –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã
			const isGameOver = safeBoardCall(() => board.isGameOver(), false);
			if (isGameOver) {
				const isCheck = safeBoardCall(() => board.isCheck(), false);
				if (isCheck) {
					return { score: isMaximizing ? -100000 : 100000, move: null };
				} else {
					return { score: 0, move: null };
				}
			}
			
			// –ü–æ–ª—É—á–∞–µ–º –ª–µ–≥–∞–ª—å–Ω—ã–µ —Ö–æ–¥—ã
			const legalMovesStr = safeBoardCall(() => board.legalMoves(), '');
			const legalMoves = legalMovesStr.split(' ').filter(m => m);
			
			if (legalMoves.length === 0) {
				return { score: 0, move: null };
			}
			
			let bestMove = null;
			let bestScore = isMaximizing ? -Infinity : Infinity;
			
			// –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ö–æ–¥—ã
			for (let move of legalMoves) {
				// –°–æ—Ö—Ä–∞–Ω—è–µ–º FEN –î–û —Ö–æ–¥–∞
				const fenBefore = safeBoardCall(() => board.fen());
				
				// –î–µ–ª–∞–µ–º —Ö–æ–¥ –Ω–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ–º board
				const moveSuccess = safeBoardCall(() => {
					try {
						board.push(move);
						return true;
					} catch (e) {
						return false;
					}
				}, false);
				
				if (!moveSuccess) continue;
				
				// –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –≤—ã–∑–æ–≤
				const result = minimaxFixed(depth - 1, !isMaximizing);
				
				// –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º board
				try {
					board.pop();
				} catch (e) {}
				
				try {
					  // –ì–ª–∞–≤–Ω–æ–µ: –∑–∞–º–µ–Ω—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π board
				} catch (e) {
					console.error('Restore error:', e);
				}
				
				// –í—ã–±–∏—Ä–∞–µ–º –ª—É—á—à–∏–π —Ö–æ–¥
				if (isMaximizing && result.score > bestScore) {
					bestScore = result.score;
					bestMove = move;
				} else if (!isMaximizing && result.score < bestScore) {
					bestScore = result.score;
					bestMove = move;
				}
			}
			
			return { score: bestScore, move: bestMove };
		}

		// –ù–û–í–ê–Ø –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π
		function sleepFrame() {
			return new Promise(resolve => requestIdleCallback(resolve, { timeout: 16 }));
		}

		async function getBestMoveWithMinimaxAsync(depth) {
			try {
				console.log(`Minimax search (depth ${depth})...`);
				
				const currentTurn = safeBoardCall(() => board.turn(), true);
				const isMaximizing = currentTurn;
				
				minimaxNodesCount = 0;
				const searchInfo = document.getElementById('search-info');
				
				// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–∫–Ω–æ –∏ –¥–∞–µ–º –±—Ä–∞—É–∑–µ—Ä—É –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∞—Ç—å—Å—è
				await new Promise(resolve => {
					requestAnimationFrame(() => {
						if (searchInfo) {
							searchInfo.innerHTML = '‚è≥ –ù–∞—á–∏–Ω–∞—é –ø–æ–∏—Å–∫...';
						}
						requestAnimationFrame(resolve);
					});
				});
				
				// –î–∞–µ–º –±—Ä–∞—É–∑–µ—Ä—É –µ—â–µ –≤—Ä–µ–º—è
				await sleepFrame();
				
				let lastUpdateTime = Date.now();
				
				minimaxUpdateCallback = (count) => {
					const now = Date.now();
					if (now - lastUpdateTime > 50 && searchInfo) {
						searchInfo.innerHTML = `‚è≥ –ü—Ä–æ—Å—á–∏—Ç–∞–Ω–æ: ${count.toLocaleString('ru-RU')} —Ö–æ–¥–æ–≤...`;
						lastUpdateTime = now;
					}
				};
				
				const startTime = Date.now();
				const result = minimaxFixed(depth, isMaximizing);
				const elapsed = Date.now() - startTime;
				
				if (searchInfo) {
					searchInfo.innerHTML = `‚úì –ü—Ä–æ—Å—á–∏—Ç–∞–Ω–æ —Ö–æ–¥–æ–≤: ${minimaxNodesCount.toLocaleString('ru-RU')} | –í—Ä–µ–º—è: ${(elapsed / 1000).toFixed(2)}—Å`;
				}
				
				console.log(`Minimax completed in ${elapsed}ms, nodes: ${minimaxNodesCount}, move: ${result.move}`);
				
				minimaxUpdateCallback = null;
				
				if (!result.move) {
					const moves = safeBoardCall(() => 
						board.legalMoves().split(' ').filter(m => m)
					);
					return moves[0] || null;
				}
				
				return result.move;
			} catch (error) {
				console.error('getBestMoveWithMinimax error:', error);
				const moves = safeBoardCall(() => 
					board.legalMoves().split(' ').filter(m => m)
				);
				return moves[0] || null;
			}
		}
		

		async function getBestMoveWithMinimax2(depth) {
			try {
				console.log(`Minimax search (depth ${depth})...`);
				
				const currentTurn = safeBoardCall(() => board.turn(), true);
				const isMaximizing = currentTurn;
				
				minimaxNodesCount = 0;
				const searchInfo = document.getElementById('search-info');
				
				// ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º requestAnimationFrame –≤–º–µ—Å—Ç–æ setTimeout
				await new Promise(resolve => {
					requestAnimationFrame(() => {
						if (searchInfo) {
							searchInfo.innerHTML = '‚è≥ –ù–∞—á–∏–Ω–∞—é –ø–æ–∏—Å–∫...';
							searchInfo.style.opacity = '1';
							searchInfo.style.visibility = 'visible';
						}
						// –î–∞–µ–º –±—Ä–∞—É–∑–µ—Ä—É –≤—Ä–µ–º—è –Ω–∞ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫—É
						setTimeout(resolve, 100);
					});
				});
				
				let lastUpdateTime = Date.now();
				let lastUpdateCount = 0;				
				
				minimaxUpdateCallback = (count) => {
					const now = Date.now();
					// –û–±–Ω–æ–≤–ª—è–µ–º UI —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø—Ä–æ—à–ª–æ 100ms —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
					if (now - lastUpdateTime > 100 && searchInfo) {
						searchInfo.innerHTML = `‚è≥ –ü—Ä–æ—Å—á–∏—Ç–∞–Ω–æ: ${count.toLocaleString('ru-RU')} —Ö–æ–¥–æ–≤...`;
						lastUpdateTime = now;
					}
				};
				
				const startTime = Date.now();
				const result = minimaxFixed(depth, isMaximizing);
				const elapsed = Date.now() - startTime;
				
				// –ü–æ–∫–∞–∑–∞—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
				if (searchInfo) {
					searchInfo.innerHTML = `‚úì –•–æ–¥–æ–≤: ${minimaxNodesCount.toLocaleString('ru-RU')} | –í—Ä–µ–º—è: ${(elapsed / 1000).toFixed(2)}—Å`;
				}
				
				console.log(`Minimax completed in ${elapsed}ms, nodes: ${minimaxNodesCount}, move: ${result.move}`);
				
				minimaxUpdateCallback = null;
				
				if (!result.move) {
					const moves = safeBoardCall(() => 
						board.legalMoves().split(' ').filter(m => m)
					);
					return moves[0] || null;
				}
				
				return result.move;
			} catch (error) {
				console.error('getBestMoveWithMinimax error:', error);
				const moves = safeBoardCall(() => 
					board.legalMoves().split(' ').filter(m => m)
				);
				return moves[0] || null;
			}
		}


		async function getBestMoveFromEngine(fen, depth) {
			try {
				// –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
				if (currentDifficulty === 0) {
					console.log('Level 0: Using Minimax (depth 2)');
					
					// ‚úÖ –î–û–ë–ê–í–ò–¢–¨: –£–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ —ç–ª–µ–º–µ–Ω—Ç –≤–∏–¥–∏–º—ã–π
					const searchInfo = document.getElementById('search-info');
					if (searchInfo) {
						searchInfo.style.display = 'block';  // ‚Üê –Ø–≤–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
						searchInfo.innerHTML = '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞...';
					}					
					
					const move = await getBestMoveWithMinimaxAsync(2);  // ‚Üê –Ω–æ–≤–æ–µ –∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏
					
					if (!move) {
						throw new Error('No moves found');
					}
					
					return { move: move, info: null };
				} else {
					// –£—Ä–æ–≤–Ω–∏ 1-7: –ò—Å–ø–æ–ª—å–∑—É–µ–º Fairy-Stockfish
					console.log('Using Fairy-Stockfish engine...');
					const response = await fetch(`${API_URL}/get-best-move`, {
						method: 'POST',
						credentials: 'include', // ‚Üê –≠–¢–û –ö–†–ò–¢–ò–ß–ù–û!						
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ fen, depth })
					});
					
					if (!response.ok) {
						throw new Error(`HTTP ${response.status}`);
					}
					
					const data = await response.json();
					return { move: data.bestMove, info: null };
				}
			} catch (error) {
				console.error('getBestMoveFromEngine error:', error);
				throw error;
			}
		}

        function makePlayerMove(move) {
            if (!gameReady) return;
            
            const currentTurn = safeBoardCall(() => board.turn(), true);
			
			//—Å–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é –≤—ã–±–æ—Ä–∞
			pendingPromotionMove = null;  
			const modal = document.getElementById('promotion-modal');
			if (modal) {
				modal.classList.remove('active');  // ‚Üê —Å–∫—Ä—ã–≤–∞–µ–º
			}			

            const fenBefore = safeBoardCall(() => board.fen(), '');
            const from = move.includes('@') ? null : move.substring(0, 2);
            const to = move.includes('@') ? move.substring(2) : move.substring(2, 4);
            
            console.log('makePlayerMove:', {move, currentTurn, playerColor, boardFlipped});
      
			// –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 2: –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –≤–∑—è—Ç–∏–µ —Ñ–∏–≥—É—Ä—ã
			let capturedPiece = null;
			if (to) {
				capturedPiece = getPieceAtSquare(fenBefore, to);
			}
	
            moveHistory.push({
                fen: fenBefore,
                whiteDragons: whiteDragons,
                blackDragons: blackDragons,
                lastMoveSquares: { ...lastMoveSquares },
                capturedByWhite: [...capturedByWhite],  // ‚Üê –î–æ–±–∞–≤–∏—Ç—å
                capturedByBlack: [...capturedByBlack]   // ‚Üê –î–æ–±–∞–≤–∏—Ç—å
            });
            			
            
            const success = safeBoardCall(() => {
                board.push(move);
                return true;
            }, false);
            
            if (!success) {
                console.error('Failed to make move:', move);
                moveHistory.pop();
                return;
            }
			
			// –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∑—è—Ç–∏—è
			if (capturedPiece && capturedPiece !== ' ') {
				if (currentTurn) {
					capturedByWhite.push(capturedPiece);
				} else {
					capturedByBlack.push(capturedPiece);
				}
			}			
            
			if (move.startsWith('D@')) {
				if (currentTurn) {
					whiteDragons--;  // –ë–µ–ª—ã–µ —Ö–æ–¥–∏–ª–∏
				} else {
					blackDragons--;  // –ß—ë—Ä–Ω—ã–µ —Ö–æ–¥–∏–ª–∏
				}
			}
            
            lastMoveSquares = { from, to };
            selectedSquare = null;
            selectedDragon = null;
			document.querySelectorAll('.pocket-pieces').forEach(p => p.classList.remove('selected'));
			
            
            updateBoard();
            updatePockets();
			updateCapturedPieces();  		
            updateEvaluation();
			updatePositionDisplay();
            
            const notation = formatMoveNotation(move, fenBefore);
            const moveColor = currentTurn ? 'white' : 'black';
            addToMoveHistory(notation, getMoveNumber(), moveColor);
            updateStatus();
            
            const isOver = safeBoardCall(() => board.isGameOver(), false);
            if (isOver) {
                handleGameEnd();
                return;
            }
            
            setTimeout(() => makeComputerMove(), 300);
        }

        async function makeComputerMove() {
            if (!gameReady) return;
            
            const currentTurn = safeBoardCall(() => board.turn(), true);
            const isComputerTurn = (playerColor === 'white' && !currentTurn && !boardFlipped) || (playerColor === 'black' && currentTurn && boardFlipped);
            
            const isOver = safeBoardCall(() => board.isGameOver(), false);
            if (!isComputerTurn || isOver) return;
            
            const thinkingDiv = document.getElementById('engine-thinking');
            const searchInfo = document.getElementById('search-info');
			
			// ‚úÖ –î–ª—è —É—Ä–æ–≤–Ω—è 0 - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ –±–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏
			if (currentDifficulty === 0) {
				thinkingDiv.classList.add('show-now');
			} else {
				thinkingDiv.classList.add('active');
			}
			
            updateStatus();
            
            try {
                const fen = safeBoardCall(() => board.fen());
                if (!fen) {
                    throw new Error('Could not get FEN');
                }
                
                const depth = difficultySettings[currentDifficulty].depth;
                const startTime = Date.now();
                const result = await getBestMoveFromEngine(fen, depth);
                const elapsed = Date.now() - startTime;
                
                // ‚úÖ –î–ª—è —É—Ä–æ–≤–Ω—è 0 –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º (–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è —É–∂–µ –≤—ã–≤–µ–¥–µ–Ω–∞ –≤ getBestMoveWithMinimaxAsync)
                if (currentDifficulty !== 0) {
                    if (result.info) {
                        searchInfo.innerHTML = `–ì–ª—É–±–∏–Ω–∞: ${result.info.depth || depth} | –ü—Ä–æ—Å—á–∏—Ç–∞–Ω–æ —Ö–æ–¥–æ–≤: ${(result.info.nodes || 0).toLocaleString('ru-RU')} | –û—Ü–µ–Ω–∫–∞: ${((result.info.score || 0) / 100).toFixed(2)}`;
                    } else {
                        searchInfo.innerHTML = `–ì–ª—É–±–∏–Ω–∞: ${depth} | –í—Ä–µ–º—è: ${(elapsed / 1000).toFixed(1)}—Å`;
                    }
                }
                
                const turnBeforeMove = safeBoardCall(() => board.turn(), true);
                const move = result.move;
                const fenBefore = safeBoardCall(() => board.fen(), '');
                const from = move.includes('@') ? null : move.substring(0, 2);
                const to = move.includes('@') ? move.substring(2) : move.substring(2, 4);
          
				// –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∑—è—Ç–∏–µ, –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–ª—è –¥—Ä–∞–∫–æ–Ω–∞
				let capturedPiece = null;
				if (to && !move.startsWith('D@')) {
					capturedPiece = getPieceAtSquare(fenBefore, to);
				}
		  				
				moveHistory.push({
					fen: fenBefore,
					whiteDragons, blackDragons,
					lastMoveSquares,
					capturedByWhite: [...capturedByWhite],
					capturedByBlack: [...capturedByBlack]
				});				
                
                const success = safeBoardCall(() => {
                    board.push(move);
                    return true;
                }, false);
                
                if (!success) {
                    throw new Error('Failed to execute move: ' + move);
                }
                
				
				// –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∑—è—Ç–∏—è
				if (capturedPiece && capturedPiece !== ' ') {
					if (turnBeforeMove) {
						capturedByWhite.push(capturedPiece);
					} else {
						capturedByBlack.push(capturedPiece);
					}
				}
		
				if (move.startsWith('D@')) {
					if (turnBeforeMove) {
						whiteDragons--;  // –ë–µ–ª—ã–µ —Ö–æ–¥–∏–ª–∏
					} else {
						blackDragons--;  // –ß—ë—Ä–Ω—ã–µ —Ö–æ–¥–∏–ª–∏
					}
				}
                
                lastMoveSquares = { from, to };
                
				//–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–∫–æ–Ω
                updateBoard();
                updatePockets();
				updateCapturedPieces(); 				
                updateEvaluation();
				updatePositionDisplay();
                
                const notation = formatMoveNotation(move, fenBefore);
                const moveColor = turnBeforeMove ? 'white' : 'black';
                addToMoveHistory(notation, getMoveNumber(), moveColor);
                
                setTimeout(() => {
                    thinkingDiv.classList.remove('active', 'show-now');
                }, 2000);
                
                updateStatus();
                
                const isGameOver = safeBoardCall(() => board.isGameOver(), false);
                if (isGameOver) handleGameEnd();
                
            } catch (error) {
                console.error('Engine error:', error);
                document.getElementById('status').textContent = '–û—à–∏–±–∫–∞ –¥–≤–∏–∂–∫–∞: ' + error.message;
                thinkingDiv.classList.remove('active', 'show-now');
            }
        }

		// –ù–û–í–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ä—É–±–ª–µ–Ω–Ω—ã—Ö —Ñ–∏–≥—É—Ä:

		function updateCapturedPieces() {
			const whiteCapturedDiv = document.getElementById('white-captured');
			const blackCapturedDiv = document.getElementById('black-captured');
			
			if (whiteCapturedDiv) {
				// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ñ–∏–≥—É—Ä—ã, –∑–∞—Ö–≤–∞—á–µ–Ω–Ω—ã–µ –±–µ–ª—ã–º–∏ (—ç—Ç–æ —á—ë—Ä–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã)
				whiteCapturedDiv.innerHTML = capturedByWhite
					.sort((a, b) => getPieceValue(b) - getPieceValue(a))
					.map(piece => `<span class="captured-piece">${getPieceSymbol(piece)}</span>`)
					.join('');
			}
			
			if (blackCapturedDiv) {
				// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ñ–∏–≥—É—Ä—ã, –∑–∞—Ö–≤–∞—á–µ–Ω–Ω—ã–µ —á—ë—Ä–Ω—ã–º–∏ (—ç—Ç–æ –±–µ–ª—ã–µ —Ñ–∏–≥—É—Ä—ã)
				blackCapturedDiv.innerHTML = capturedByBlack
					.sort((a, b) => getPieceValue(b) - getPieceValue(a))
					.map(piece => `<span class="captured-piece">${getPieceSymbol(piece)}</span>`)
					.join('');
			}
		}
		
		// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –ø–æ —Ü–µ–Ω–Ω–æ—Å—Ç–∏:
		function getPieceValue(piece) {
			const values = {
				'q': 9, 'Q': 9,
				'r': 6, 'R': 6,
				'b': 5, 'B': 5,
				'd': 4, 'D': 4,
				'n': 3, 'N': 3,
				'p': 1, 'P': 1
			};
			return values[piece] || 0;
		}		
		
        function updateBoard() {
            const boardDiv = document.getElementById('board');
            if (!boardDiv) return;
            
            boardDiv.innerHTML = '';
            
            const fen = safeBoardCall(() => board.fen());
            if (!fen) {
                console.error('Cannot get FEN');
                return;
            }
            
            if (!boardFlipped) {
                for (let rank = 8; rank >= 1; rank--) {
                    for (let file = 0; file < 8; file++) {
                        const fileChar = String.fromCharCode(97 + file);
                        const square = fileChar + rank;
                        createSquare(square, fen);
                    }
                }
            } else {
                for (let rank = 1; rank <= 8; rank++) {
                    for (let file = 7; file >= 0; file--) {
                        const fileChar = String.fromCharCode(97 + file);
                        const square = fileChar + rank;
                        createSquare(square, fen);
                    }
                }
            }
            
            highlightLastMove();
            
            if (selectedDragon) {
                highlightDragonDrops();
            }
        }

        function createSquare(square, fen) {
            const squareDiv = document.createElement('div');
            const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
            const rank = parseInt(square[1]) - 1;
            const isLight = (file + rank) % 2 === 0;
            
            squareDiv.className = `square ${isLight ? 'light' : 'dark'}`;
            squareDiv.dataset.square = square;
            
            const piece = getPieceAtSquare(fen, square);
            if (piece) {
                const pieceSpan = document.createElement('span');
                pieceSpan.className = 'piece';
                pieceSpan.textContent = getPieceSymbol(piece);
                squareDiv.appendChild(pieceSpan);
            }
            
            squareDiv.addEventListener('click', () => handleSquareClick(square));
            document.getElementById('board').appendChild(squareDiv);
        }


		function handleSquareClick(square) {
			if (!gameReady) return;
			
			const currentTurn = safeBoardCall(() => board.turn(), true);
			const isPlayerTurn = (playerColor === 'white' && currentTurn) || (playerColor === 'black' && !currentTurn);
			
			if (!isPlayerTurn) {
				console.log('Not player turn');
				return;
			}
			
			const legalMovesStr = safeBoardCall(() => board.legalMoves(), '');
			const legalMoves = legalMovesStr.split(' ').filter(m => m);
			
			if (selectedSquare) {
				const move = selectedSquare + square;
				if (legalMoves.includes(move)) {
					makePlayerMove(move);
					return;
				}
				
				const promotions = ['q', 'r', 'b', 'n', 'd'];
				for (let promo of promotions) {
					if (legalMoves.includes(move + promo)) {
						showPromotionDialog(move);
						return;
					}
				}
			}
			
			if (selectedDragon) {
				// –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º 'D@' –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ü–≤–µ—Ç–∞!
				const dropMove = 'D@' + square;
				console.log('Trying dragon drop:', {dropMove, square, legalMoves, includes: legalMoves.includes(dropMove)});
				if (legalMoves.includes(dropMove)) {
					makePlayerMove(dropMove);
					return;
				} else {
					console.warn('Dragon drop not legal!', dropMove);
				}
			}
			
			const fen = safeBoardCall(() => board.fen(), '');
			const piece = getPieceAtSquare(fen, square);
			if (piece && ((playerColor === 'white' && piece === piece.toUpperCase()) || (playerColor === 'black' && piece === piece.toLowerCase()))) {
				selectedSquare = square;
				selectedDragon = null;
				updateBoard();
				highlightLegalMoves(square);
			}
		}


        function highlightLegalMoves(fromSquare) {
            const legalMovesStr = safeBoardCall(() => board.legalMoves(), '');
            const legalMoves = legalMovesStr.split(' ').filter(m => m);
            const movesFromSquare = legalMoves.filter(m => m.startsWith(fromSquare));
            
            movesFromSquare.forEach(move => {
                const to = move.substring(2, 4);
                const squareEl = document.querySelector(`[data-square="${to}"]`);
                if (squareEl) {
                    squareEl.classList.add('legal-move');
                    const fen = safeBoardCall(() => board.fen(), '');
                    const hasPiece = getPieceAtSquare(fen, to) !== null;
                    if (hasPiece) squareEl.classList.add('has-piece');
                }
            });
        }

		function highlightDragonDrops() {
			const legalMovesStr = safeBoardCall(() => board.legalMoves(), '');
			const legalMoves = legalMovesStr.split(' ').filter(m => m);
			
			// –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: Fairy-Stockfish –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç 'D@' –¥–ª—è –¥—Ä–∞–∫–æ–Ω–æ–≤ –ª—é–±–æ–≥–æ —Ü–≤–µ—Ç–∞!
			const dragonDropMoves = legalMoves.filter(m => m.startsWith('D@'));
			
			console.log('Dragon drops (all colors):', dragonDropMoves);
			
			dragonDropMoves.forEach(move => {
				const square = move.substring(2); // –£–±–∏—Ä–∞–µ–º 'D@'
				const squareEl = document.querySelector(`[data-square="${square}"]`);
				if (squareEl) {
					squareEl.classList.add('dragon-drop');
				}
			});
		}


        function highlightLastMove() {
            if (lastMoveSquares.from) {
                const fromEl = document.querySelector(`[data-square="${lastMoveSquares.from}"]`);
                if (fromEl) fromEl.classList.add('last-move');
            }
            if (lastMoveSquares.to) {
                const toEl = document.querySelector(`[data-square="${lastMoveSquares.to}"]`);
                if (toEl) toEl.classList.add('last-move');
            }
        }

        function updatePockets() {
            const whiteP = document.getElementById('white-pocket');
            const blackP = document.getElementById('black-pocket');
            if (whiteP) whiteP.textContent = '‚ô§'.repeat(whiteDragons) || '‚Äî';
            if (blackP) blackP.textContent = '‚ô†'.repeat(blackDragons) || '‚Äî';
        }
		
		function updateDragonsFromFen(fen) {
			// –ü–∞—Ä—Å–∏–º –∫–∞—Ä–º–∞–Ω—ã –∏–∑ FEN
			// –§–æ—Ä–º–∞—Ç: rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR[DDdd] w - - 0 1
			const pocketMatch = fen.match(/\[([^\]]+)\]/);
			
			if (pocketMatch) {
				const pockets = pocketMatch[1];
				whiteDragons = (pockets.match(/D/g) || []).length;
				blackDragons = (pockets.match(/d/g) || []).length;
			} else {
				// –ï—Å–ª–∏ –∫–∞—Ä–º–∞–Ω–æ–≤ –Ω–µ—Ç –≤ FEN, —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –¥—Ä–∞–∫–æ–Ω—ã –Ω–∞ –¥–æ—Å–∫–µ –∏–ª–∏ –≤–∑—è—Ç—ã
				whiteDragons = 2; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
				blackDragons = 2;
			}
			
			updatePockets();
		}
		

        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 2: –¶–≤–µ—Ç–∞ —à–∫–∞–ª—ã –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ü–≤–µ—Ç–∞ –∏–≥—Ä–æ–∫–∞
        function updateEvaluation() {
            const fen = safeBoardCall(() => board.fen());
            if (!fen) return;
            
            const boardStr = fen.split(' ')[0].split('[')[0];
            let score = 0;
            //const values = {'P':100,'N':320,'B':330,'R':500,'Q':900,'D':310,'p':-100,'n':-320,'b':-330,'r':-500,'q':-900,'d':-350};
            
            for (let char of boardStr) {
                if (pieceValues[char]) score += pieceValues[char];
            }
            
            const playerScore = playerColor === 'white' ? score : -score;
            
            const evalText = document.getElementById('evaluation-text');
            const playerSection = document.getElementById('evaluation-player');
            const computerSection = document.getElementById('evaluation-computer');
            
            if (evalText && playerSection && computerSection) {
                const displayScore = (playerScore / 100).toFixed(1);
                evalText.textContent = playerScore > 0 ? `+${displayScore}` : displayScore;
                evalText.classList.remove('positive', 'negative', 'neutral');
                
                if (playerScore > 50) {
                    evalText.classList.add('positive');
                } else if (playerScore < -50) {
                    evalText.classList.add('negative');
                } else {
                    evalText.classList.add('neutral');
                }
                
                const maxScore = 2000;
                const clampedScore = Math.max(-maxScore, Math.min(maxScore, playerScore));
                const percentage = ((clampedScore / maxScore) + 1) * 50;
                
                // –ò–≥—Ä–æ–∫ —Å–ª–µ–≤–∞, –∫–æ–º–ø—å—é—Ç–µ—Ä —Å–ø—Ä–∞–≤–∞
                playerSection.style.left = '0';
                playerSection.style.width = `${percentage}%`;
                
                computerSection.style.left = `${percentage}%`;
                computerSection.style.width = `${100 - percentage}%`;
                
                // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 2: –¶–≤–µ—Ç–∞ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ü–≤–µ—Ç–∞ –∏–≥—Ä–æ–∫–∞
                if (playerColor === 'white') {
                    // –ò–≥—Ä–æ–∫ –∏–≥—Ä–∞–µ—Ç –±–µ–ª—ã–º–∏: –±–µ–ª—ã–π —Å–ª–µ–≤–∞, —Å–µ—Ä—ã–π —Å–ø—Ä–∞–≤–∞
                    playerSection.style.background = '#ecf0f1';
                    computerSection.style.background = '#95a5a6';
                } else {
                    // –ò–≥—Ä–æ–∫ –∏–≥—Ä–∞–µ—Ç —á—ë—Ä–Ω—ã–º–∏: —Å–µ—Ä—ã–π —Å–ª–µ–≤–∞, –±–µ–ª—ã–π —Å–ø—Ä–∞–≤–∞
                    playerSection.style.background = '#95a5a6';
                    computerSection.style.background = '#ecf0f1';
                }
            }
        }

        function updateStatus() {
            const statusDiv = document.getElementById('status');
            if (!statusDiv) return;
            
            if (!gameReady) {
                statusDiv.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞...';
                return;
            }
            
            const turn = safeBoardCall(() => board.turn(), true);
            const isPlayerTurn = (playerColor === 'white' && turn && !boardFlipped) || (playerColor === 'black' && !turn && boardFlipped);
            const colorName = playerColor === 'white' ? '–±–µ–ª—ã–µ' : '—á—ë—Ä–Ω—ã–µ';
            
            const isOver = safeBoardCall(() => board.isGameOver(), false);
            const isCheck = safeBoardCall(() => board.isCheck(), false);
            
            if (isOver) {
                if (isCheck) {
                    const winner = turn ? '—á—ë—Ä–Ω—ã–µ' : '–±–µ–ª—ã–µ';
                    statusDiv.textContent = `–ú–∞—Ç! –ü–æ–±–µ–¥–∏–ª–∏ ${winner}`;
                } else {
                    statusDiv.textContent = '–ü–∞—Ç - –Ω–∏—á—å—è';
                }
            } else if (isCheck) {
                statusDiv.textContent = '–®–∞—Ö!';
            } else if (isPlayerTurn) {
                statusDiv.textContent = `–í–∞—à —Ö–æ–¥ (${colorName})`;
            } else {
                statusDiv.textContent = '–•–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞...';
            }
        }

        function updateCoordinates() {
            const fileLabels = boardFlipped ? ['h','g','f','e','d','c','b','a'] : ['a','b','c','d','e','f','g','h'];
            const rankLabels = boardFlipped ? ['1','2','3','4','5','6','7','8'] : ['8','7','6','5','4','3','2','1'];
            
            const fileLabelsDiv = document.getElementById('file-labels');
            const rankLabelsDiv = document.getElementById('rank-labels');
            
            if (fileLabelsDiv) {
                fileLabelsDiv.innerHTML = fileLabels.map(f => `<span>${f}</span>`).join('');
            }
            if (rankLabelsDiv) {
                rankLabelsDiv.innerHTML = rankLabels.map(r => `<span>${r}</span>`).join('');
            }
        }

		function getPieceAtSquare(fen, square) {
			// ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
			if (!fen || !square || square.length < 2) return null;
			
			const parts = fen.split(' ');
			const position = parts[0].split('[')[0];
			const ranks = position.split('/');
			
			const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
			const rank = 8 - parseInt(square[1]);
			
			// ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ ranks[rank] —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ —ç—Ç–æ —Å—Ç—Ä–æ–∫–∞
			if (rank < 0 || rank >= 8 || !ranks[rank] || typeof ranks[rank] !== 'string') {
				return null;
			}
			
			let fileIndex = 0;
            for (let char of ranks[rank]) {
                if (char >= '1' && char <= '8') {
                    fileIndex += parseInt(char);
                } else {
                    if (fileIndex === file) return char;
                    fileIndex++;
                }
            }
			return null;
		}

        function getPieceAtSquare2(fen, square) {
            const parts = fen.split(' ');
            const position = parts[0].split('[')[0];
            const ranks = position.split('/');
            
            const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
            const rank = 8 - parseInt(square[1]);
            
			// ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω—ã –ø—Ä–æ–≤–µ—Ä–∫–∏:
			if (!fen || !square || square.length < 2) return null;
			if (rank < 0 || rank >= 8 || !ranks[rank]) return null;  // ‚Üê –ü—Ä–æ–≤–µ—Ä–∫–∞ ranks[rank]
            
            let fileIndex = 0;
            for (let char of ranks[rank]) {
                if (char >= '1' && char <= '8') {
                    fileIndex += parseInt(char);
                } else {
                    if (fileIndex === file) return char;
                    fileIndex++;
                }
            }
            return null;
        }

        function getPieceSymbol(piece) {
            const symbols = {
                'P': '‚ôô', 'N': '‚ôò', 'B': '‚ôó', 'R': '‚ôñ', 'Q': '‚ôï', 'K': '‚ôî', 'D': '‚ô§',
                'p': '‚ôü', 'n': '‚ôû', 'b': '‚ôù', 'r': '‚ôú', 'q': '‚ôõ', 'k': '‚ôö', 'd': '‚ô†'
            };
            return symbols[piece] || piece;
        }

		function formatMoveNotation(move, fenBefore) {
			let notation = '';
			
			// ‚úÖ –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º —à–∞—Ö –∏ –º–∞—Ç –ü–û–°–õ–ï —Ö–æ–¥–∞
			let isCheck = false;
			let isMate = false;
	
			// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã ffish
			try {
				isCheck = safeBoardCall(() => board.isCheck(), false);
				// –ú–∞—Ç = —à–∞—Ö + –Ω–µ—Ç –ª–µ–≥–∞–ª—å–Ω—ã—Ö —Ö–æ–¥–æ–≤
				isMate = safeBoardCall(() => 
					board.isCheck() && board.legalMoves() === "", 
					false
				);
			} catch (e) {
				console.warn('Error checking position:', e);
			}			
			
			
			////
			
			if (move.includes('@')) {
				// ‚úÖ –•–û–î–´ –î–†–ê–ö–û–ù–û–í
				const piece = move[0] === 'D' ? '‚ô§' : '‚ô†';
				const square = move.substring(2);
				
				// –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∑—è—Ç–∏–µ
				try {
					const targetPiece = getPieceAtSquare(fenBefore, square);
					if (targetPiece && targetPiece !== ' ') {
						notation = `${piece}x${square}`;  // –í–∑—è—Ç–∏–µ
					} else {
						notation = `${piece}@${square}`;
					}
				} catch (e) {
					notation = `${piece}@${square}`;
				}
				
				// –î–æ–±–∞–≤–ª—è–µ–º —à–∞—Ö/–º–∞—Ç
				if (isMate) {
					notation += '#';  // ‚Üê –ú–ê–¢!
				} else if (isCheck) {
					notation += '+';  // ‚Üê –®–ê–•!
				}
				
				return notation;
			}
			
			// ‚úÖ –û–ë–´–ß–ù–´–ï –•–û–î–´
			const from = move.substring(0, 2);
			const to = move.substring(2, 4);
			let piece = null;
			
			try {
				piece = getPieceAtSquare(fenBefore, from);
			} catch (e) {}
			
			const symbol = piece ? getPieceSymbol(piece) : '';
			
			// –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∑—è—Ç–∏–µ
			try {
				const targetPiece = getPieceAtSquare(fenBefore, to);
				if (targetPiece && targetPiece !== ' ') {
					notation = `${symbol}${from}x${to}`;  // ‚Üê –í–ó–Ø–¢–ò–ï
				} else {
					notation = `${symbol}${from}-${to}`;
				}
			} catch (e) {
				notation = `${symbol}${from}-${to}`;
			}
			
			// –î–æ–±–∞–≤–ª—è–µ–º —à–∞—Ö/–º–∞—Ç
			if (isMate) {
				notation += '#';  // ‚Üê –ú–ê–¢!
			} else if (isCheck) {
				notation += '+';  // ‚Üê –®–ê–•!
			}
			
			return notation;
		}

        function formatMoveNotation2(move, fenBefore) {
            if (move.includes('@')) {
                const piece = move[0] === 'D' ? '‚ô§' : '‚ô†';
                const square = move.substring(2);
                return `${piece}@${square}`;
            }
            
            const from = move.substring(0, 2);
            const to = move.substring(2, 4);
            const piece = getPieceAtSquare(fenBefore, from);
            const symbol = piece ? getPieceSymbol(piece) : '';
            
            return `${symbol}${from}-${to}`;
        }

        function getMoveNumber() {
            const fen = safeBoardCall(() => board.fen(), '');
            if (!fen) return 1;
            const parts = fen.split(' ');
            return parseInt(parts[parts.length - 1]) || 1;
        }

        let moveHistoryData = [];

        function addToMoveHistory(notation, moveNum, color) {
            if (color === 'white') {
                moveHistoryData.push({ number: moveNum, white: notation, black: '' });
            } else {
                if (moveHistoryData.length > 0 && !moveHistoryData[moveHistoryData.length - 1].black) {
                    moveHistoryData[moveHistoryData.length - 1].black = notation;
                } else {
                    moveHistoryData.push({ number: moveNum, white: '', black: notation });
                }
            }
            renderMoveHistory();
        }

        function renderMoveHistory() {
            const historyDiv = document.getElementById('move-history');
            if (!historyDiv) return;
            
            historyDiv.innerHTML = moveHistoryData.slice().reverse().map(m => 
                `<div class="move-pair">
                    <span class="move-number">${m.number}.</span>
                    <span class="move">${m.white}</span>
                    <span class="move">${m.black}</span>
                </div>`
            ).join('');
        }

        function handleGameEnd() {
            setTimeout(() => {
                const turn = safeBoardCall(() => board.turn(), true);
                const isCheck = safeBoardCall(() => board.isCheck(), false);
                
                if (isCheck) {
                    const winner = turn ? '–ß—ë—Ä–Ω—ã–µ' : '–ë–µ–ª—ã–µ';
                    alert(`–ú–∞—Ç! ${winner} –ø–æ–±–µ–¥–∏–ª–∏!`);
                } else {
                    alert('–ü–∞—Ç! –ù–∏—á—å—è.');
                }
            }, 500);
        }

		function showPromotionDialog(movePrefix) {
			pendingPromotionMove = movePrefix;
			
			const modal = document.getElementById('promotion-modal');
			const piecesContainer = document.getElementById('promotion-pieces');
			
			if (!modal || !piecesContainer) {
				console.error('Promotion modal not found!');
				makePlayerMove(movePrefix + 'q');  // Fallback
				return;
			}
			
			const currentTurn = safeBoardCall(() => board.turn(), true);
			const isWhite = (playerColor === 'white' && currentTurn) || 
							(playerColor === 'black' && !currentTurn);
			
			const promotionOptions = [
				{ piece: 'q', symbol: isWhite ? '‚ôï' : '‚ôõ' },
				{ piece: 'r', symbol: isWhite ? '‚ôñ' : '‚ôú' },
				{ piece: 'b', symbol: isWhite ? '‚ôó' : '‚ôù' },
				{ piece: 'n', symbol: isWhite ? '‚ôò' : '‚ôû' },
				{ piece: 'd', symbol: isWhite ? '‚ô§' : '‚ô†' }
			];
			
			piecesContainer.innerHTML = '';
			
			promotionOptions.forEach(opt => {
				const button = document.createElement('button');
				button.className = 'promotion-piece-btn';
				button.textContent = opt.symbol;
				button.onclick = () => selectPromotion(opt.piece);
				piecesContainer.appendChild(button);
			});
			
			modal.classList.add('active');
		}


		function selectPromotion(piece) {
			const modal = document.getElementById('promotion-modal');
			modal.classList.remove('active');
			
			if (pendingPromotionMove) {
				const fullMove = pendingPromotionMove + piece;
				makePlayerMove(fullMove);
				pendingPromotionMove = null;
			}
		}		

        function selectDragon(color) {
            if (!gameReady) return;
            
            const turn = safeBoardCall(() => board.turn(), true);
            const isPlayerTurn = (playerColor === 'white' && turn) || (playerColor === 'black' && !turn);
            
            const fen = safeBoardCall(() => board.fen(), '');
            console.log('selectDragon:', {
                color, 
                playerColor, 
                turn, 
                isPlayerTurn, 
                whiteDragons, 
                blackDragons,
                fen
            });
            
            if (!isPlayerTurn) {
                console.log('Not player turn, cannot select dragon');
                return;
            }
            if (color === 'white' && whiteDragons === 0) return;
            if (color === 'black' && blackDragons === 0) return;
            
            if ((color === 'white' && playerColor !== 'white') || (color === 'black' && playerColor !== 'black')) {
                console.log('Cannot select opponent dragon');
                return;
            }
            
            if (selectedDragon === color) {
                selectedDragon = null;
                document.querySelectorAll('.pocket-pieces').forEach(p => p.classList.remove('selected'));
            } else {
                selectedDragon = color;
                selectedSquare = null;
                document.querySelectorAll('.pocket-pieces').forEach(p => p.classList.remove('selected'));
                document.getElementById(`${color}-pocket`).classList.add('selected');
            }
            
            updateBoard();
        }
		
		// –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ textarea
		function setPositionFromInput() {
			const textarea = document.getElementById('position-input');
			const newFen = textarea.value.trim();
			
			if (!newFen) {
				alert('–í–≤–µ–¥–∏—Ç–µ FEN –ø–æ–∑–∏—Ü–∏—é');
				return;
			}
			
			try {
				board.delete();
				const newBoard = new ffish.Board('ChessDragon', newFen);
				board = newBoard;
				
				//originalFen = newFen;
				
				// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —á–µ–π —Ö–æ–¥ –∏–∑ FEN:
				//const parts = newFen.split(' ')
				//if (parts.length > 1) {
					// parts[1] ‚Äî —ç—Ç–æ 'w' –∏–ª–∏ 'b'
				//	board.turn() = (parts[1] === 'w') ? true : false
				//}
				
				updateBoard();
				updateDragonsFromFen(newFen);
				updateEvaluation();
				updateStatus();
				
				// !!! –î–∞–ª—å—à–µ ‚Äî –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–¥–æ –ª–∏ –æ—Ç–¥–∞—Ç—å —Ö–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä—É:
				// –ß–µ–ª–æ–≤–µ–∫ –∏–≥—Ä–∞–µ—Ç –¢–û–ô —Å—Ç–æ—Ä–æ–Ω–æ–π, –∫–æ—Ç–æ—Ä–∞—è "–≤–Ω–∏–∑—É" (–æ–±—ã—á–Ω–æ –±–µ–ª—ã–µ, –µ—Å–ª–∏ –Ω–µ boardFlipped)
				// –ï—Å–ª–∏ —Å–µ–π—á–∞—Å –∫–æ–º–ø—å—é—Ç–µ—Ä –¥–æ–ª–∂–µ–Ω —Ö–æ–¥–∏—Ç—å, –≤—ã–∑–æ–≤–∏ makeComputerMove
				const turn = board.turn(); // true ‚Äî –±–µ–ª—ã–µ, false ‚Äî —á–µ—Ä–Ω—ã–µ
				const humanIsWhite = !boardFlipped; // –µ—Å–ª–∏ –Ω–µ boardFlipped ‚Äî —á–µ–ª–æ–≤–µ–∫ –±–µ–ª—ã–º–∏
				const isComputerTurn = (humanIsWhite && !turn) || (!humanIsWhite && turn);
				if (isComputerTurn) {
					setTimeout(makeComputerMove, 400);
				}				
				
				const btn = document.getElementById('position-toggle-btn');
				btn.textContent = '–°–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é';
				//btn.style.background = '#e74c3c';
				btn.onclick = function() {
					togglePositionDisplay();
				};
				
				//alert('‚úì –ü–æ–∑–∏—Ü–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞');
			} catch (error) {
				alert('‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω–∞—è FEN –Ω–æ—Ç–∞—Ü–∏—è');
			}
		}

		// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ FEN –ø—Ä–∏ –∫–∞–∂–¥–æ–º —Ö–æ–¥–µ
		function updatePositionDisplay() {
			const display = document.getElementById('position-display');
			const textarea = document.getElementById('position-input');
			const btn = document.getElementById('position-toggle-btn');
			
			if (positionDisplayVisible && display.classList.contains('active')) {
				const currentFen = safeBoardCall(() => board.fen());
				originalFen = currentFen;
				textarea.value = currentFen;
				
				btn.textContent = '–°–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é';
				//btn.style.background = '#e74c3c';
				btn.onclick = function() {
					togglePositionDisplay();
				};
			}
		}
		

        window.newGame = function() {
            moveHistoryData = [];
            initGame();
        };

        window.flipBoard = function() {
            playerColor = playerColor === 'white' ? 'black' : 'white';
            boardFlipped = !boardFlipped;
            updateBoard();
            updateCoordinates();
            updateEvaluation();
            updateStatus();
            
            const turn = safeBoardCall(() => board.turn(), true);
            const isComputerTurn = (playerColor === 'white' && !turn) || (playerColor === 'black' && turn);
            
            if (isComputerTurn) {
                setTimeout(() => makeComputerMove(), 300);
            }
        };

        window.undoMove = function() {
            if (moveHistory.length === 0) {
                alert('–ù–µ—á–µ–≥–æ –æ—Ç–º–µ–Ω—è—Ç—å!');
                return;
            }
            
            const lastState = moveHistory.pop();

            try {
                board.delete();
                board = new ffish.Board('ChessDragon', lastState.fen);
                whiteDragons = lastState.whiteDragons;
                blackDragons = lastState.blackDragons;
                lastMoveSquares = lastState.lastMoveSquares;
 
				// ‚úÖ –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–∑—è—Ç—ã–µ —Ñ–∏–≥—É—Ä—ã
                capturedByWhite = lastState.capturedByWhite ? [...lastState.capturedByWhite] : [];
                capturedByBlack = lastState.capturedByBlack ? [...lastState.capturedByBlack] : [];
                 
                if (moveHistoryData.length > 0) {
                    const lastMove = moveHistoryData[moveHistoryData.length - 1];
                    if (lastMove.black) {
                        lastMove.black = '';
                    } else {
                        moveHistoryData.pop();
                    }
                }
                
                updateBoard();
                updatePockets();
				updateCapturedPieces();  // ‚Üê –î–æ–±–∞–≤–∏—Ç—å				
                updateEvaluation();
				updatePositionDisplay();
                updateStatus();
                renderMoveHistory();
				
            } catch (error) {
                console.error('Undo error:', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ —Ö–æ–¥–∞');
            }
        };

		// –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏ (–ì–õ–û–ë–ê–õ–¨–ù–ê–Ø)
		window.togglePositionDisplay = function() {
			const display = document.getElementById('position-display');
			const textarea = document.getElementById('position-input');
			const btn = document.getElementById('position-toggle-btn');
			
			if (!positionDisplayVisible) {
				// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
				const currentFen = safeBoardCall(() => board.fen());
				originalFen = currentFen;
				textarea.value = currentFen;
				
				display.classList.add('active');
				positionDisplayVisible = true;
				btn.textContent = '–°–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é';
				//btn.style.background = '#e74c3c';  // –ö—Ä–∞—Å–Ω–∞—è –∫–Ω–æ–ø–∫–∞
			} else {
				// –°–∫—Ä—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
				display.classList.remove('active');
				positionDisplayVisible = false;
				btn.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–∑–∏—Ü–∏—é';
				btn.style.background = '';  // –í–µ—Ä–Ω—É—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ü–≤–µ—Ç
				originalFen = '';
			}
		}

		// –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ textarea
		window.onPositionChanged = function() {
			const textarea = document.getElementById('position-input');
			const btn = document.getElementById('position-toggle-btn');
			const currentFen = safeBoardCall(() => board.fen());
			
			if (textarea.value !== originalFen && textarea.value !== currentFen) {
				// –ü–æ–∑–∏—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞
				btn.textContent = '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é';
				btn.style.background = '#27ae60';  // –ó–µ–ª—ë–Ω–∞—è –∫–Ω–æ–ø–∫–∞
				btn.onclick = function() {
					setPositionFromInput();
				};
			} else {
				// –ü–æ–∑–∏—Ü–∏—è –≤–µ—Ä–Ω—É–ª–∞—Å—å –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—É
				btn.textContent = '–°–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é';
				//btn.style.background = '#e74c3c';  // –ö—Ä–∞—Å–Ω–∞—è –∫–Ω–æ–ø–∫–∞
				btn.onclick = function() {
					togglePositionDisplay();
				};
			}
		}

        window.setDifficulty = function(level) {
            currentDifficulty = parseInt(level);
        };

        window.selectDragon = selectDragon;

		document.addEventListener('DOMContentLoaded', () => {
			const modal = document.getElementById('promotion-modal');
			if (modal) {
				modal.style.display = 'none';
				modal.classList.remove('active');
			}
			initGame();
		});
		
		// –ó–∞–∫—Ä—ã—Ç–∏–µ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –µ–≥–æ
		document.addEventListener('click', function(e) {
			const modal = document.getElementById('promotion-modal');
			if (e.target === modal) {
				modal.classList.remove('active');
				pendingPromotionMove = null;
			}
		});		
		

        // ‚úÖ –ê–í–¢–û–ò–ì–†–ê (–ü–†–û–°–¢–ê–Ø –í–ï–†–°–ò–Ø)
        window.autoPlayEnabled = false;

        window.toggleAutoPlay = function(){
            window.autoPlayEnabled = !window.autoPlayEnabled;
            const btn = document.getElementById('autobtn');

            if (window.autoPlayEnabled) {
                playerColor = 'none';  // –†–µ–∂–∏–º –∫–æ–º–ø—å—é—Ç–µ—Ä vs –∫–æ–º–ø—å—é—Ç–µ—Ä
                btn.style.background = '#f44336';
                btn.textContent = '‚èπ –ê–≤—Ç–æ';
                console.log('‚úÖ –ê–í–¢–û–ò–ì–†–ê –í–ö–õ–Æ–ß–ï–ù–ê');
                autoPlayNextMove();
            } else {
                btn.style.background = '#4CAF50';
                btn.textContent = 'üêâ –ê–≤—Ç–æ–∏–≥—Ä–∞';
                console.log('üõë –ê–í–¢–û–ò–ì–†–ê –í–´–ö–õ–Æ–ß–ï–ù–ê');
            }
        }

        function autoPlayNextMove() {
            if (!window.autoPlayEnabled) return;

            try {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã
                const isGameOver = safeBoardCall(() => board.isGameOver(), false);
                if (isGameOver) {
                    window.autoPlayEnabled = false;
                    document.getElementById('autobtn').style.background = '#4CAF50';
                    document.getElementById('autobtn').textContent = 'üêâ –ê–≤—Ç–æ–∏–≥—Ä–∞';
                    console.log('‚èπ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞');
                    return;
                }

                // –î–µ–ª–∞–µ–º —Ö–æ–¥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞
                makeComputerMove().then(() => {
                    console.log('‚úì –•–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω');
                    if (window.autoPlayEnabled) {
                        setTimeout(autoPlayNextMove, 1000);
                    }
                }).catch(e => {
                    console.error('–û—à–∏–±–∫–∞ —Ö–æ–¥–∞:', e);
                    window.autoPlayEnabled = false;
                });
            } catch(e) {
                console.error('–û—à–∏–±–∫–∞ –∞–≤—Ç–æ-–∏–≥—Ä—ã:', e);
                window.autoPlayEnabled = false;
            }
        }

    
        // ‚úÖ –û–ß–ï–ù–¨ –ü–û–î–†–û–ë–ù–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï FEN –û–®–ò–ë–û–ö
        function isValidFEN(fen) {
            if (!fen || typeof fen !== 'string') {
                console.error('‚ùå FEN –Ω–µ —Å—Ç—Ä–æ–∫–∞ –∏–ª–∏ –ø—É—Å—Ç–∞');
                return false;
            }

            let fullFen = fen.trim();
            let pocket = '';

            console.log('üìã –ü—Ä–æ–≤–µ—Ä—è–µ–º FEN:', fullFen);
            console.log('üìç –î–ª–∏–Ω–∞ FEN:', fullFen.length, '—Å–∏–º–≤–æ–ª–æ–≤');

            // –ò—â–µ–º –∫–∞—Ä–º–∞–Ω [...]
            const pocketMatch = fullFen.match(/\[([a-zA-Z]*)\]/);
            if (pocketMatch) {
                pocket = pocketMatch[1];
                console.log('üì¶ –ù–∞–π–¥–µ–Ω –∫–∞—Ä–º–∞–Ω: [' + pocket + ']');
                fullFen = fullFen.replace(pocketMatch[0], '');
                console.log('üìã FEN –±–µ–∑ –∫–∞—Ä–º–∞–Ω–∞:', fullFen);
            } else {
                console.log('üì¶ –ö–∞—Ä–º–∞–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω (—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —à–∞—Ö–º–∞—Ç—ã)');
            }

            const parts = fullFen.trim().split(/\s+/);
            console.log('üìä –ß–∞—Å—Ç–∏ FEN:', parts);
            console.log('üìä –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–µ–π:', parts.length);

            if (parts.length !== 6) {
                console.error('‚ùå –û–®–ò–ë–ö–ê: –î–æ–ª–∂–Ω–æ –±—ã—Ç—å 6 —á–∞—Å—Ç–µ–π, –Ω–∞–π–¥–µ–Ω–æ:', parts.length);
                console.log('   –î–æ–ª–∂–Ω–æ –±—ã—Ç—å: board turn castling enpassant halfmove fullmove');
                console.log('   –ü–æ–ª—É—á–µ–Ω–æ:', parts);
                return false;
            }

            const [board, turn, castling, enPassant, halfmove, fullmove] = parts;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å–∫—É
            console.log('\nüîç –ü—Ä–æ–≤–µ—Ä—è–µ–º –î–û–°–ö–£:', board);
            const rows = board.split('/');
            console.log('   –†—è–¥–æ–≤:', rows.length, '(–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 8)');
            if (rows.length !== 8) {
                console.error('‚ùå –û–®–ò–ë–ö–ê –≤ –¥–æ—Å–∫–µ: –Ω–µ–≤–µ—Ä–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä—è–¥–æ–≤');
                return false;
            }
            console.log('‚úÖ –î–æ—Å–∫–∞ OK');

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º turn
            console.log('\nüîç –ü—Ä–æ–≤–µ—Ä—è–µ–º TURN:', turn);
            if (!/^[wb]$/.test(turn)) {
                console.error('‚ùå –û–®–ò–ë–ö–ê: turn –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å w –∏–ª–∏ b, –ø–æ–ª—É—á–µ–Ω–æ:', turn);
                return false;
            }
            console.log('‚úÖ Turn OK');

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º castling
            console.log('\nüîç –ü—Ä–æ–≤–µ—Ä—è–µ–º CASTLING:', castling);
            if (!/^(-|K?Q?k?q?)$/.test(castling)) {
                console.error('‚ùå –û–®–ò–ë–ö–ê: castling –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å - –∏–ª–∏ KQkq, –ø–æ–ª—É—á–µ–Ω–æ:', castling);
                return false;
            }
            console.log('‚úÖ Castling OK');

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º enPassant
            console.log('\nüîç –ü—Ä–æ–≤–µ—Ä—è–µ–º EN PASSANT:', enPassant);
            if (!/^(-|[a-h][36])$/.test(enPassant)) {
                console.error('‚ùå –û–®–ò–ë–ö–ê: enPassant –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å - –∏–ª–∏ e3, –ø–æ–ª—É—á–µ–Ω–æ:', enPassant);
                return false;
            }
            console.log('‚úÖ EnPassant OK');

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º halfmove
            console.log('\nüîç –ü—Ä–æ–≤–µ—Ä—è–µ–º HALFMOVE:', halfmove);
            if (!/^\d+$/.test(halfmove)) {
                console.error('‚ùå –û–®–ò–ë–ö–ê: halfmove –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —á–∏—Å–ª–æ, –ø–æ–ª—É—á–µ–Ω–æ:', halfmove);
                return false;
            }
            console.log('‚úÖ Halfmove OK');

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º fullmove
            console.log('\nüîç –ü—Ä–æ–≤–µ—Ä—è–µ–º FULLMOVE:', fullmove);
            if (!/^\d+$/.test(fullmove)) {
                console.error('‚ùå –û–®–ò–ë–ö–ê: fullmove –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —á–∏—Å–ª–æ, –ø–æ–ª—É—á–µ–Ω–æ:', fullmove);
                return false;
            }
            console.log('‚úÖ Fullmove OK');

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—Ä–º–∞–Ω
            if (pocket) {
                console.log('\nüîç –ü—Ä–æ–≤–µ—Ä—è–µ–º –ö–ê–†–ú–ê–ù: [' + pocket + ']');
                if (!/^[pnbrqkPNBRQK]*$/.test(pocket)) {
                    console.error('‚ùå –û–®–ò–ë–ö–ê: –∫–∞—Ä–º–∞–Ω —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã');
                    console.log('   –î–æ–ø—É—Å—Ç–∏–º—ã–µ: p n b r q k P N B R Q K');
                    console.log('   –ü–æ–ª—É—á–µ–Ω–æ:', pocket);
                    return false;
                }
                console.log('‚úÖ –ö–∞—Ä–º–∞–Ω OK');
            }

            console.log('\n‚úÖ‚úÖ‚úÖ FEN –í–ê–õ–ò–î–ù–ê! ‚úÖ‚úÖ‚úÖ');
            return true;
        }

        function loadFENPosition(fen) {
            try {
                console.log('\n' + '='.repeat(50));
                console.log('–ó–ê–ì–†–£–ó–ö–ê FEN –ü–û–ó–ò–¶–ò–ò');
                console.log('='.repeat(50));
                console.log('üìã FEN:', fen);

                if (!isValidFEN(fen)) {
                    console.error('\n‚ùå FEN –ù–ï –ü–†–û–®–õ–ê –í–ê–õ–ò–î–ê–¶–ò–Æ!');
                    alert('‚ùå –û–®–ò–ë–ö–ê: –ù–µ–≤–µ—Ä–Ω–∞—è FEN –Ω–æ—Ç–∞—Ü–∏—è!\n\n' +
                        '–û—Ç–∫—Ä–æ–π—Ç–µ Console (F12) —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –¥–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏.');
                    return false;
                }

                // –£–¥–∞–ª—è–µ–º –∫–∞—Ä–º–∞–Ω –¥–ª—è board.load()
                let cleanFen = fen.trim();
                const pocketMatch = cleanFen.match(/\[([a-zA-Z]*)\]/);
                if (pocketMatch) {
                    cleanFen = cleanFen.replace(pocketMatch[0], '');
                }

                console.log('\nüéÆ –ó–∞–≥—Ä—É–∂–∞–µ–º –≤ board.load():', cleanFen);

                const result = safeBoardCall(() => {
                    board.load(cleanFen);
                    return true;
                }, false);

                if (result) {
                    console.log('‚úÖ board.load() –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!');
                    updateBoard();
                    console.log('‚úÖ –î–æ—Å–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞ —ç–∫—Ä–∞–Ω–µ!');
                    console.log('\nüéâ –ü–û–ó–ò–¶–ò–Ø –ó–ê–ì–†–£–ñ–ï–ù–ê!\n');
                    return true;
                } else {
                    console.error('‚ùå board.load() –≤–µ—Ä–Ω—É–ª–∞ false');
                    alert('‚ùå –û—à–∏–±–∫–∞: board.load() –Ω–µ –≤—ã–ø–æ–ª–Ω–∏–ª–∞—Å—å!');
                    return false;
                }
            } catch(e) {
                console.error('\n‚ùå –ò–°–ö–õ–Æ–ß–ï–ù–ò–ï:', e.message);
                console.error('Stack:', e.stack);
                alert('‚ùå –û–®–ò–ë–ö–ê: ' + e.message);
                return false;
            }
        }

</script>
	
</body>
</html>